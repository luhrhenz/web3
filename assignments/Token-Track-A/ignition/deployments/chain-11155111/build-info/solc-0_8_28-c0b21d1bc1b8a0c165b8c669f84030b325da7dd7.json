{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-c0b21d1bc1b8a0c165b8c669f84030b325da7dd7",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/erc721.sol": "project/contracts/erc721.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/erc721.sol": {
        "content": "// SPDX-License-Identifier: SEE LICENSE IN LICENSE\npragma solidity ^0.8.28;\n\n\ninterface IERC165 {\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\ninterface IERC721 is IERC165 {\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    function balanceOf(address owner) external view returns (uint256 balance);\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) external;\n\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    function approve(address to, uint256 tokenId) external;\n    function getApproved(uint256 tokenId) external view returns (address);\n    function setApprovalForAll(address operator, bool _approved) external;\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n\ninterface IERC721Metadata is IERC721 {\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n\ninterface IERC721Receiver {\n    function onERC721Received(address operator, address from, uint256 tokenId, bytes calldata data) external returns (bytes4);\n}\n\ncontract ERC721 is IERC721Metadata {\n    string private _name;\n    string private _symbol;\n    string private _baseURI;\n\n    mapping(uint256 => address) private _owners;\n    mapping(address => uint256) private _balances;\n\n    mapping(uint256 => address) private _tokenApprovals;\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    constructor(string memory name_, string memory symbol_, string memory baseURI_) {\n        _name = name_;\n        _symbol = symbol_;\n        _baseURI = baseURI_;    \n    }\n\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return\n            interfaceId == type(IERC165).interfaceId ||\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId;\n    }\n\n    function name() external view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() external view  returns (string memory) {\n        return _symbol;\n    }\n\n    function tokenURI(uint256 tokenId) external view returns (string memory) {\n        require(_exists(tokenId), \"ERC721: URI query for nonexistent token\");\n        string memory base = _baseURI;\n        return bytes(base).length > 0 ? string(abi.encodePacked(base, _toString(tokenId))) : \"\";\n    }\n\n    function balanceOf(address owner) external view returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    function ownerOf(uint256 tokenId) external view returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    function _exists(uint256 tokenId) internal view returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    function approve(address to, uint256 tokenId) external {\n        address owner = _owners[tokenId];\n        require(_exists(tokenId), \"ERC721: approve nonexistent token\");\n        require(to != owner, \"ERC721: approval to current owner\");\n        require(\n            msg.sender == owner || isApprovedForAll(owner, msg.sender),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n        _tokenApprovals[tokenId] = to;\n        emit Approval(owner, to, tokenId);\n    }\n\n    function getApproved(uint256 tokenId) public view returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n        return _tokenApprovals[tokenId];\n    }\n\n    function setApprovalForAll(address operator, bool approved) external {\n        _operatorApprovals[msg.sender][operator] = approved;\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function isApprovedForAll(address owner, address operator) public view  returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    function isApprovedOrOwner(address spender, uint256 tokenId) public view returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = _owners[tokenId];\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    function transferFrom(address from, address to, uint256 tokenId) external {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\n        _transfer(from, to, tokenId);\n    }\n\n    function _transfer(address from, address to, uint256 tokenId) internal  {\n        require(_owners[tokenId] == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        // Clear approvals\n        _tokenApprovals[tokenId] = address(0); //or delete _tokenApprovals[tokenId];\n        emit Approval(from, address(0), tokenId);   \n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId) external  {\n        safeTransferFrom(from, to, tokenId, new bytes(0));\n    }\n\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public  {\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal  {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    function _mint(address to, uint256 tokenId) internal  {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    function mint(address to, uint256 tokenId) external {\n        _mint(to, tokenId);\n    }\n\n    function burn(uint256 tokenId) external {\n        address owner = _owners[tokenId];\n        require(_isApprovedOrOwner(msg.sender, tokenId), \"ERC721: caller is not token owner or approved\");\n        require(_exists(tokenId), \"ERC721: burn nonexistent token\");\n        \n        delete _tokenApprovals[tokenId]; // Clear approvals\n        emit Approval(owner, address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId]; // or _owners[tokenId] = address(0);\n        // _owners[tokenId] = address(0);\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\n        address owner = _owners[tokenId];\n        return (spender == owner || isApprovedForAll(owner, spender) || _tokenApprovals[tokenId] == spender);\n    }\n\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(msg.sender, from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    function _toString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n}\n"
      }
    }
  }
}