{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-21451e536308c69dfb7d4f468eb6162638ddafd9",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/Staking.sol": "project/contracts/Staking.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/erc20.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.28;\n\ncontract ERC20 {\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n\n    uint256 private _totalSupply;\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    constructor(string memory _name, string memory _symbol, uint8 _decimals, uint256 initialSupply) {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        _mint(msg.sender, initialSupply);\n    }\n\n    function totalSupply() external view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balances[account];\n    }\n\n    function allowance(address owner, address spender) external view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function _transfer(address from, address to, uint256 amount) internal {\n        // Sender is `from`, receiver is `to` (caller can be sender or an approved spender).\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 senderBalance = _balances[from];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n\n        unchecked {\n            _balances[from] -= amount;\n            _balances[to] += amount;\n        }\n        emit Transfer(from, to, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal {\n        // Receiver is `account` (called by the contract, e.g., constructor).\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n\n        emit Transfer(address(0), account, amount);\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        // Sender (msg.sender) is the token owner; receiver is the `spender` being approved.\n        require(msg.sender != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _burn(uint256 amount) internal  {\n        // Sender (msg.sender) burns their own tokens; no receiver (sent to address(0)).\n        require(msg.sender != address(0), \"ERC20: cannot burn from address(0)\");\n\n        // uint256 _balances = _balances[msg.sender];\n        require(_balances[msg.sender] >= amount, \"ERC20: burn amount exceeds balance\");\n\n        unchecked {\n            _balances[msg.sender] -= amount;\n            _totalSupply -= amount;\n            _balances[address(0)] += amount;\n        }\n        emit Transfer(msg.sender, address(0), amount);\n    }\n\n    function transferFrom(address from, address to, uint256 amount) external returns (bool) {\n        // Sender (msg.sender) is the spender; `from` is the token owner; `to` is the receiver.\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        uint256 currentAllowance = _allowances[from][msg.sender];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n\n        unchecked {\n            _allowances[from][msg.sender] = currentAllowance - amount;\n        }\n        emit Approval(from, msg.sender, _allowances[from][msg.sender]);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n    _transfer(msg.sender, to, amount);\n    return true;\n    }\n\n    function mint (uint256 amount) external returns (bool) {\n        _mint(msg.sender, amount);\n        return true;\n    }\n}    "
      },
      "project/contracts/Staking.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSE\npragma solidity ^0.8.28;\n\nimport \"./erc20.sol\";\n\n/**\n * @title StakingPool\n * @dev Individual staking pool for a specific token\n */\ncontract StakingPool {\n    // The staking token\n    ERC20 public stakingToken;\n    // The reward token\n    ERC20 public rewardToken;\n    \n    // Pool parameters\n    uint256 public rewardRate; // Rewards per second\n    uint256 public lockPeriod; // Lock period in seconds\n    uint256 public penaltyRate; // Penalty percentage (in basis points, e.g., 1000 = 10%)\n    \n    // Pool state\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n    uint256 public totalStaked;\n    \n    // User data\n    struct UserInfo {\n        uint256 amount; // Staked amount\n        uint256 rewardDebt; // Reward debt for calculation\n        uint256 pendingRewards; // Accumulated pending rewards\n        uint256 stakeTime; // Timestamp when staked\n        uint256 lastClaimTime; // Last time user claimed rewards\n    }\n    \n    mapping(address => UserInfo) public userInfo;\n    \n    // Events\n    event Staked(address indexed user, uint256 amount);\n    event Withdrawn(address indexed user, uint256 amount, uint256 penalty);\n    event RewardsClaimed(address indexed user, uint256 amount);\n    event EmergencyWithdrawn(address indexed user, uint256 amount);\n    event RewardRateUpdated(uint256 oldRate, uint256 newRate);\n    event LockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event PenaltyRateUpdated(uint256 oldRate, uint256 newRate);\n    \n    // Modifiers\n    modifier updateReward(address account) {\n        _updateReward(account);\n        _;\n    }\n    \n    constructor(\n        address _stakingToken,\n        address _rewardToken,\n        uint256 _rewardRate,\n        uint256 _lockPeriod,\n        uint256 _penaltyRate\n    ) {\n        require(_stakingToken != address(0), \"Invalid staking token\");\n        require(_rewardToken != address(0), \"Invalid reward token\");\n        require(_penaltyRate <= 10000, \"Penalty rate too high\"); // Max 100%\n        \n        stakingToken = ERC20(_stakingToken);\n        rewardToken = ERC20(_rewardToken);\n        rewardRate = _rewardRate;\n        lockPeriod = _lockPeriod;\n        penaltyRate = _penaltyRate;\n        lastUpdateTime = block.timestamp;\n    }\n    \n    /**\n     * @dev Calculate reward per token\n     */\n    function rewardPerToken() public view returns (uint256) {\n        if (totalStaked == 0) {\n            return rewardPerTokenStored;\n        }\n        return rewardPerTokenStored + (\n            (block.timestamp - lastUpdateTime) * rewardRate * 1e18 / totalStaked\n        );\n    }\n    \n    /**\n     * @dev Calculate earned rewards for a user\n     */\n    function earned(address account) public view returns (uint256) {\n        UserInfo storage user = userInfo[account];\n        uint256 rewardPerTokenValue = rewardPerToken();\n        return user.pendingRewards + (\n            user.amount * (rewardPerTokenValue - user.rewardDebt) / 1e18\n        );\n    }\n    \n    /**\n     * @dev Internal function to update reward state\n     */\n    function _updateReward(address account) internal {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = block.timestamp;\n        \n        if (account != address(0)) {\n            UserInfo storage user = userInfo[account];\n            user.pendingRewards = earned(account);\n            user.rewardDebt = rewardPerTokenStored;\n        }\n    }\n    \n    /**\n     * @dev Stake tokens into the pool\n     * @param amount Amount of tokens to stake\n     */\n    function stake(uint256 amount) external updateReward(msg.sender) {\n        require(amount > 0, \"Cannot stake 0\");\n        \n        // Transfer tokens from user to pool\n        require(\n            stakingToken.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n        \n        UserInfo storage user = userInfo[msg.sender];\n        \n        // If user already has stake, claim pending rewards first\n        if (user.amount > 0) {\n            uint256 pending = user.pendingRewards + (\n                user.amount * (rewardPerTokenStored - user.rewardDebt) / 1e18\n            );\n            user.pendingRewards = pending;\n        }\n        \n        user.amount += amount;\n        user.stakeTime = block.timestamp;\n        user.rewardDebt = rewardPerTokenStored;\n        totalStaked += amount;\n        \n        emit Staked(msg.sender, amount);\n    }\n    \n    /**\n     * @dev Withdraw staked tokens\n     * @param amount Amount to withdraw\n     */\n    function withdraw(uint256 amount) external updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        require(user.amount >= amount, \"Insufficient staked balance\");\n        require(amount > 0, \"Cannot withdraw 0\");\n        \n        uint256 penalty = 0;\n        \n        // Check if lock period has passed\n        if (block.timestamp < user.stakeTime + lockPeriod) {\n            // Apply penalty for early withdrawal\n            penalty = amount * penaltyRate / 10000;\n        }\n        \n        uint256 withdrawAmount = amount - penalty;\n        \n        // Update state before transfer\n        user.amount -= amount;\n        user.rewardDebt = rewardPerTokenStored;\n        totalStaked -= amount;\n        \n        // Transfer staked tokens back to user\n        require(\n            stakingToken.transfer(msg.sender, withdrawAmount),\n            \"Transfer failed\"\n        );\n        \n        // If there's a penalty, send it to the contract owner or burn\n        // For simplicity, we keep it in the contract as protocol fees\n        // Alternatively, could transfer to a fee collector\n        \n        emit Withdrawn(msg.sender, withdrawAmount, penalty);\n    }\n    \n    /**\n     * @dev Claim accumulated rewards\n     */\n    function claimRewards() external updateReward(msg.sender) {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 pending = earned(msg.sender);\n        \n        require(pending > 0, \"No rewards to claim\");\n        \n        user.pendingRewards = 0;\n        user.lastClaimTime = block.timestamp;\n        user.rewardDebt = rewardPerTokenStored;\n        \n        // Transfer reward tokens to user\n        require(\n            rewardToken.transfer(msg.sender, pending),\n            \"Reward transfer failed\"\n        );\n        \n        emit RewardsClaimed(msg.sender, pending);\n    }\n    \n    /**\n     * @dev Emergency withdraw - withdraw all staked tokens without claiming rewards\n     * Applies penalty if within lock period\n     */\n    function emergencyWithdraw() external {\n        UserInfo storage user = userInfo[msg.sender];\n        uint256 amount = user.amount;\n        \n        require(amount > 0, \"No stake to withdraw\");\n        \n        uint256 penalty = 0;\n        \n        // Check if lock period has passed\n        if (block.timestamp < user.stakeTime + lockPeriod) {\n            penalty = amount * penaltyRate / 10000;\n        }\n        \n        uint256 withdrawAmount = amount - penalty;\n        \n        // Reset user state\n        user.amount = 0;\n        user.pendingRewards = 0;\n        user.rewardDebt = rewardPerTokenStored;\n        totalStaked -= amount;\n        \n        // Transfer staked tokens\n        require(\n            stakingToken.transfer(msg.sender, withdrawAmount),\n            \"Transfer failed\"\n        );\n        \n        emit EmergencyWithdrawn(msg.sender, withdrawAmount);\n    }\n    \n    /**\n     * @dev Update reward rate (only callable by factory/owner)\n     * @param newRate New reward rate per second\n     */\n    function setRewardRate(uint256 newRate) external {\n        // In production, this should have access control\n        // For simplicity, we'll implement a basic version\n        _updateReward(address(0));\n        \n        uint256 oldRate = rewardRate;\n        rewardRate = newRate;\n        \n        emit RewardRateUpdated(oldRate, newRate);\n    }\n    \n    /**\n     * @dev Update lock period\n     * @param newPeriod New lock period in seconds\n     */\n    function setLockPeriod(uint256 newPeriod) external {\n        // In production, this should have access control\n        uint256 oldPeriod = lockPeriod;\n        lockPeriod = newPeriod;\n        \n        emit LockPeriodUpdated(oldPeriod, newPeriod);\n    }\n    \n    /**\n     * @dev Update penalty rate\n     * @param newRate New penalty rate in basis points\n     */\n    function setPenaltyRate(uint256 newRate) external {\n        // In production, this should have access control\n        require(newRate <= 10000, \"Penalty rate too high\");\n        \n        uint256 oldRate = penaltyRate;\n        penaltyRate = newRate;\n        \n        emit PenaltyRateUpdated(oldRate, newRate);\n    }\n    \n    /**\n     * @dev Get user info\n     */\n    function getUserInfo(address user) external view returns (\n        uint256 amount,\n        uint256 pendingRewards,\n        uint256 stakeTime,\n        uint256 lastClaimTime,\n        uint256 availableRewards\n    ) {\n        UserInfo storage info = userInfo[user];\n        return (\n            info.amount,\n            info.pendingRewards,\n            info.stakeTime,\n            info.lastClaimTime,\n            earned(user)\n        );\n    }\n    \n    /**\n     * @dev Check if user can withdraw without penalty\n     */\n    function canWithdrawWithoutPenalty(address user) external view returns (bool) {\n        UserInfo storage info = userInfo[user];\n        return block.timestamp >= info.stakeTime + lockPeriod;\n    }\n    \n    /**\n     * @dev Get time remaining until lock expires\n     */\n    function timeUntilUnlock(address user) external view returns (uint256) {\n        UserInfo storage info = userInfo[user];\n        if (block.timestamp >= info.stakeTime + lockPeriod) {\n            return 0;\n        }\n        return (info.stakeTime + lockPeriod) - block.timestamp;\n    }\n}\n\n\n/**\n * @title StakingFactory\n * @dev Factory contract to create and manage multiple staking pools\n */\ncontract StakingFactory {\n    address public owner;\n    \n    struct PoolInfo {\n        address poolAddress;\n        address stakingToken;\n        address rewardToken;\n        uint256 rewardRate;\n        uint256 lockPeriod;\n        uint256 penaltyRate;\n        bool active;\n    }\n    \n    mapping(uint256 => PoolInfo) public pools;\n    mapping(address => uint256[]) public userPools; // User's staked pools\n    uint256 public poolCount;\n    \n    event PoolCreated(\n        uint256 indexed poolId,\n        address indexed poolAddress,\n        address stakingToken,\n        address rewardToken,\n        uint256 rewardRate,\n        uint256 lockPeriod,\n        uint256 penaltyRate\n    );\n    \n    event PoolDeactivated(uint256 indexed poolId);\n    event PoolActivated(uint256 indexed poolId);\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    constructor() {\n        owner = msg.sender;\n    }\n    \n    /**\n     * @dev Create a new staking pool\n     */\n    function createPool(\n        address stakingToken,\n        address rewardToken,\n        uint256 rewardRate,\n        uint256 lockPeriod,\n        uint256 penaltyRate\n    ) external onlyOwner returns (uint256 poolId, address poolAddress) {\n        require(stakingToken != address(0), \"Invalid staking token\");\n        require(rewardToken != address(0), \"Invalid reward token\");\n        \n        poolId = poolCount;\n        \n        StakingPool pool = new StakingPool(\n            stakingToken,\n            rewardToken,\n            rewardRate,\n            lockPeriod,\n            penaltyRate\n        );\n        \n        poolAddress = address(pool);\n        \n        pools[poolId] = PoolInfo({\n            poolAddress: poolAddress,\n            stakingToken: stakingToken,\n            rewardToken: rewardToken,\n            rewardRate: rewardRate,\n            lockPeriod: lockPeriod,\n            penaltyRate: penaltyRate,\n            active: true\n        });\n        \n        poolCount++;\n        \n        emit PoolCreated(\n            poolId,\n            poolAddress,\n            stakingToken,\n            rewardToken,\n            rewardRate,\n            lockPeriod,\n            penaltyRate\n        );\n        \n        return (poolId, poolAddress);\n    }\n    \n    /**\n     * @dev Get pool info\n     */\n    function getPool(uint256 poolId) external view returns (PoolInfo memory) {\n        require(poolId < poolCount, \"Pool does not exist\");\n        return pools[poolId];\n    }\n    \n    /**\n     * @dev Get all pools\n     */\n    function getAllPools() external view returns (PoolInfo[] memory) {\n        PoolInfo[] memory allPools = new PoolInfo[](poolCount);\n        for (uint256 i = 0; i < poolCount; i++) {\n            allPools[i] = pools[i];\n        }\n        return allPools;\n    }\n    \n    /**\n     * @dev Deactivate a pool\n     */\n    function deactivatePool(uint256 poolId) external onlyOwner {\n        require(poolId < poolCount, \"Pool does not exist\");\n        pools[poolId].active = false;\n        emit PoolDeactivated(poolId);\n    }\n    \n    /**\n     * @dev Activate a pool\n     */\n    function activatePool(uint256 poolId) external onlyOwner {\n        require(poolId < poolCount, \"Pool does not exist\");\n        pools[poolId].active = true;\n        emit PoolActivated(poolId);\n    }\n    \n    /**\n     * @dev Update pool parameters\n     */\n    function updatePoolParams(\n        uint256 poolId,\n        uint256 newRewardRate,\n        uint256 newLockPeriod,\n        uint256 newPenaltyRate\n    ) external onlyOwner {\n        require(poolId < poolCount, \"Pool does not exist\");\n        \n        StakingPool pool = StakingPool(pools[poolId].poolAddress);\n        \n        if (newRewardRate != pools[poolId].rewardRate) {\n            pool.setRewardRate(newRewardRate);\n            pools[poolId].rewardRate = newRewardRate;\n        }\n        \n        if (newLockPeriod != pools[poolId].lockPeriod) {\n            pool.setLockPeriod(newLockPeriod);\n            pools[poolId].lockPeriod = newLockPeriod;\n        }\n        \n        if (newPenaltyRate != pools[poolId].penaltyRate) {\n            pool.setPenaltyRate(newPenaltyRate);\n            pools[poolId].penaltyRate = newPenaltyRate;\n        }\n    }\n    \n    /**\n     * @dev Fund a pool with reward tokens\n     */\n    function fundPool(uint256 poolId, uint256 amount) external onlyOwner {\n        require(poolId < poolCount, \"Pool does not exist\");\n        \n        PoolInfo storage poolInfo = pools[poolId];\n        ERC20 rewardToken = ERC20(poolInfo.rewardToken);\n        \n        require(\n            rewardToken.transferFrom(msg.sender, poolInfo.poolAddress, amount),\n            \"Transfer failed\"\n        );\n    }\n    \n    /**\n     * @dev Transfer ownership\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid owner\");\n        owner = newOwner;\n    }\n}\n"
      }
    }
  }
}